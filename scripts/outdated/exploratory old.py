import os, ast
import numpy as np
import pandas as pd

#THIS FILE IS OBSOLETE, IT WAS USED TO MAKE A DATABASE VIA PER-MERGING
#BUT THE PROJECT WAS SWITCHED TO DYNAMIC MERGING TO PREVENT BLOATING

# Creates an EDA spreadsheet and calculates DPS, DPE, TDO for further analsys
# DPS (Damage Per Second) is determined by the max attack power from a combination of 
# fast and charged attacks over a set time period (STAB is included)
# STAB is same type attack bonus; an extra damage buff if the pokemon is of same type as the move
# DPE (Damage Per Energy) is the max damage that can be delivered over a setup of charging fast attck
# then using the charged attack (STAB is included)
# TDO (Total Damage Output) will be total damage the pokemon can deliver
# before fainting (DPS * survival time). This is a rough estimate and survival time will be proportional to stamina, HP, and health

battlebuilds_sheet_dir = 'data/processed/app_calcs/battlebuilds.csv'
EDA_data = 'data/processed/app_calcs/EDA_data.csv'
class gen_parameters:
    def __init__(self, sheet):
        self.sheet = sheet
        df = pd.read_csv(sheet)
        self.CPM_l50 = 0.8403 #create a constant for the CP multiplier at lvl 50
        self.incoming_damage = 10 #create a constant for the incoming damage (not accurate)
        #Most of these parameter calcs are for PVE, which may be useful in later versions
        #The following parameters are from the Game Master file or calculated by the damage formula
        #REF: https://pogo.gamepress.gg/how-calculate-comprehensive-dps#:~:text=Solve%20the%20above%20linear%20system,xHP)%E2%8B%85y
        self.FDmg, self.FDur, self.Fe, self.CDmg, self.CDur, self.Ce = df['power'], df['duration'], df['energy_delta'], df['power_charged'], df['duration_charged'], -df['energy_delta_charged']
        self.DPS, self.FEPS, self.CDPS, self.CEPS = self.FDmg/self.FDur, self.Fe/self.FDur, self.CDmg/self.CDur, self.Ce/self.CDur
        self.b_ATK, self.b_DEF, self.b_STA, self.max_CP = df['base_attack'], df['base_defense'], df['base_stamina'], df['max_cp']
        #Defender values, standardized for EDA
        self.d_DEF, self.d_EFF = 10,1
        #max HP of a 0,0,0 IV pokemon: using for now
        self.HP = np.floor((self.b_STA/10)*self.CPM_l50)
        #adjust the fast and charged atk dmg based off of the pokemon stats
        self.adj_FDmg, self.adj_CDmg = self.FDmg*(self.b_ATK/self.d_DEF), self.CDmg*(self.b_ATK/self.d_DEF)

def calc_DPE_and_STAB(pkb,df,EDA):
    df['type'] = df['type'].apply(ast.literal_eval)
    df['STAB_mult'] = df.apply(lambda row: 1.2 if row['type_charged'] in row['type'] else 1, axis=1)
    EDA['STAB_f'],EDA['STABs_c'] = df.apply(lambda row: 1.2 if row['type_fast'] in row['type'] else 1, axis=1), df['STAB_mult'].values
    EDA['DPE'] = round((pkb.adj_CDmg * df['STAB_mult'])/pkb.Ce, 2) #energy is only used when a charged attack is used
    EDA.to_csv(EDA_data, index=False)
    print(f"DPE and STAB data added to {EDA_data}!")

def calc_eff_DPS(pkb,EDA):
    #Damage Per Second is the time it takes to charge up charged attack using fast attacks
    #we include damage per energy and damage from unused energy because some fast attacks overcharge charged attacks
    #this assumes that the player immediately uses the charged attack when available
    #Additionally, I did not account for charged attack use time because in the course of a pvp battle the enemy
    #cannot attack back when using a charged attack so technically it takes no time in the sense of the battle
    
    Fatk_per_Catk = np.ceil(pkb.Ce/pkb.Fe) #the number of fast attacks to charge our charged attack (there will be overcharge)
    en_gen = Fatk_per_Catk*pkb.Fe #energy generated by doing this
    unused_en = en_gen - pkb.Ce #the left over energy after the charged attack
    time_used = Fatk_per_Catk*pkb.FDur #total combat time used to make the moves
    dmg_unused_en = (unused_en/pkb.Ce)*EDA['STABs_c']*pkb.adj_CDmg #the amount of dmg from a charged attack at remaining energy (if that was possible)
    tot_Dmg = EDA['STABs_c']*pkb.adj_CDmg*1 + EDA['STAB_f']*pkb.adj_FDmg*Fatk_per_Catk + dmg_unused_en#equal to (charged damage per energy * energy) + fast move damage (adjust both for STAB)
    eff_DPS = tot_Dmg/time_used
    EDA['eff_DPS'] = round(eff_DPS,2)
    EDA.to_csv(EDA_data, index=False)
    print(f"Effective DPS data added to {EDA_data}!")

def calc_eff_TDO(pkb,EDA): #also involves HP
    EDA['stats'] = EDA['stats'].apply(ast.literal_eval)
    stamina = EDA['stats'].apply(lambda x: x[2]) 
    EDA['HP'] = np.floor(stamina*pkb.CPM_l50).astype(int) #HP is stamina value times the cp multiplier
    TTF = EDA['HP']/pkb.incoming_damage #effective time to faint
    eff_TDO = EDA['eff_DPS'] * TTF
    EDA['eff_TDO'] = round(eff_TDO,2)
    EDA.to_csv(EDA_data, index=False)
    print(f"Effective TDO data added to {EDA_data}!")

def run_calcs():
    params = gen_parameters(battlebuilds_sheet_dir)
    df = pd.read_csv(battlebuilds_sheet_dir)
    if not os.path.exists(EDA_data):
        print(f"Creating {EDA_data}")
        EDA_write = pd.DataFrame(columns=['pokemon_name', 'type',
                                         'IVs', 'stats', 'level', 'CP', 
                                         'fast_move', 'fm_type', 'STAB_f', 'charged_moves', 
                                         'cm_types', 'STABs_c', 'DPE', 'eff_DPS', 'eff_TDO'])
        EDA_write['pokemon_name'] = df['pokemon_name'].values
        EDA_write['type'] = df['type'].values
        EDA_write['fast_move'] = df['fast_moves'].values
        EDA_write['fm_type'] = df['type_fast'].values
        EDA_write['charged_moves'] = df['charged_moves'].values
        EDA_write['cm_types'] = df['type_charged'].values
        EDA_write['stats'] = df.apply(lambda row: [row['base_attack'], row['base_defense'], row['base_stamina']], axis=1)

        EDA_write.to_csv('data/processed/app_calcs/EDA_data.csv', index=False)
    EDA = pd.read_csv(EDA_data)
    missing_vals = [EDA['DPE'].isna().all(), EDA['eff_DPS'].isna().all(), EDA['eff_TDO'].isna().all()]
    if True in missing_vals:
        calc_DPE_and_STAB(params,df,EDA)
        calc_eff_DPS(params,EDA)
        calc_eff_TDO(params,EDA)

def main():
    run_calcs()
